---
title: "EDA For DDS Project"
author: "Jonathon Roach"
date: "10/14/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(class)
library(stringr)
library(forcats)
library(modelr)
theme_set(theme_bw())
beers <- read.csv("http://raw.githubusercontent.com/BivinSadler/MDS-6306-Doing-Data-Science-Fall-2019/master/Unit%208%20and%209%20Case%20Study%201/Beers.csv")
breweries <- read.csv("https://raw.githubusercontent.com/BivinSadler/MDS-6306-Doing-Data-Science-Fall-2019/master/Unit%208%20and%209%20Case%20Study%201/Breweries.csv")
```


## Introduction


The following is an analysis of market trends pertaining to 2,410 US craft beers brewed at 558 breweries. In this presentation, our goal is to model and communicate relationships between brewery location, beer alcoholic content (ABV), and beer bitterness (IBU). 


# Question 1

Let's start with a simple question: Which state has the most breweries? A simple tally reveals that Colorado is the state with the most breweries. California and Michigan follow closely behind.

```{r message=FALSE, warning=FALSE}

breweries %>%
  group_by(State) %>%
  summarize(count=n()) %>%
  arrange(desc(count))

```


# Question 2

For ease of analysis, we will now merge the provided beers and breweries data sets. 

```{r message=FALSE, warning=FALSE}
dat <- left_join(beers, breweries, by=c("Brewery_id" = "Brew_ID")) %>%
       rename(Beer = Name.x, Brewery = Name.y)
head(dat)
```

# Question 3

Let's consider the missing data in our data set. What percentage of values are missing for each data element?

```{r}
unlist(lapply(dat, function(x)mean(is.na(x))*100))
```



# Question 4 

Which states generally have the beer with the highest alcohol content?

```{r}
dat %>%
  mutate(State = fct_reorder(State, ABV, .fun = median, na.rm = TRUE, .desc = TRUE)) %>%
  group_by(State) %>%
  summarise(medABV = median(ABV, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(aes(State, medABV)) +
  theme(axis.text.x = element_text(angle = 90)) +
  geom_bar(stat = "identity")
```

```{r}
dat %>%
  mutate(State = fct_reorder(State, IBU, .fun = median, na.rm = TRUE, .desc = TRUE)) %>%
  group_by(State) %>%
  summarise(medIBU = median(IBU, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(aes(State, medIBU)) +
  theme(axis.text.x = element_text(angle = 90)) +
  geom_bar(stat = "identity")
```


# Question 5

Which state has the beer with the highest ABV? Which state has the most bitter beer?

```{r}
dat %>%
  arrange(desc(ABV)) %>%
  select(State, ABV, Beer)
```


```{r}
dat %>%
  arrange(desc(IBU)) %>%
  select(State, IBU, Beer)
```


# Question 6


```{r}

summary(dat$ABV)

```


```{r}

dat %>%
  ggplot(aes(ABV)) +
  geom_histogram() +
  labs(x="% Alcohol by Volume",
       y="",
       title = "Distribution of Alcohol by Volume",
       subtitle = "From a Sample of 2,410 US Craft Beers")

```


# Question 7

```{r message=FALSE, warning=FALSE}
dat %>%
  ggplot(aes(x=ABV, y=IBU)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE) +
    labs(title = "Relationship Between Alcohol by Volume and Bitterness")
```

Seems like there are Breweries going by the same name in different cities. We may need to accout for this later. It's going to be important for us to reference beweries by Brew_ID rather than name. 

```{r message=FALSE, warning=FALSE}
duplicates <- breweries %>% 
  group_by(Name) %>%
  summarise(count=n()) %>%
  arrange(desc(count)) %>%
  filter(count == 2) %>%
  select(Name)
breweries %>% 
  filter(Name %in% duplicates$Name) %>%
  arrange(Name)
```



Which style of beer is most commonly brewed?


```{r message=FALSE, warning=FALSE}
head(
beers %>%
  group_by(Style) %>%
  summarise(count = n()) %>%
  arrange(desc(count))
)
```



Which brewery produces the most individual beer types?

```{r message=FALSE, warning=FALSE}

dat %>%
  group_by(Brewery) %>%
  summarise(count = n()) %>%
  arrange(desc(count))

```


Same question, but for city

```{r}

dat %>%
  group_by(City) %>%
  summarise(count = n()) %>%
  arrange(desc(count))

```


Let's identify the IPA's

```{r message=FALSE, warning=FALSE}
dat$is_IPA <- str_detect(dat$Style, "IPA")
head(dat %>% filter(is_IPA == TRUE) %>% select(Beer, is_IPA, Style))
```


We can see below that our REGEX isn't picking up anything that it shouldn't. 

```{r message=FALSE, warning=FALSE}
unique(dat[str_detect(dat$Style, "IPA"),]$Style)
```


Now let's identify the ales (including IPA's). We need to be careful. Just looking for the string, "ale" is not a precise solution. For example, "Yard S[ale] Winter Lager" is not an ale, and we don't want it to get picked up in our results.

```{r message=FALSE, warning=FALSE}
dat$is_ale <- str_detect(dat$Beer, "ale")
head(dat %>% filter(is_ale == TRUE) %>% select(Beer, is_ale, Style) )
```

We will also need to be careful using REGEX on the Style column, as simply searching for the "ale" string doesn't guarantee that we're selecting ales either (see for example: "Euro P[ale] Lager")

```{r message=FALSE, warning=FALSE}
unique(dat[str_detect(dat$Style, "ale"),]$Style)
```


Looks like searching for "Ale" is the more sensible decision. 

```{r message=FALSE, warning=FALSE}
unique(dat[str_detect(dat$Style, "Ale"),]$Style)
```


```{r message=FALSE, warning=FALSE}
dat$is_ale <- str_detect(dat$Beer, "Ale")
head(dat %>% filter(is_ale == TRUE) %>% select(Beer, is_ale, Style) )
```

```{r message=FALSE, warning=FALSE}
ales <- dat %>% filter(is_ale == TRUE) %>% select(Beer, is_ale, Style) 
head(
ales %>%
  group_by(Style) %>%
  summarise(count = n()) %>%
  arrange(desc(count))  
)
```

Hmm...Why are there beers like "Witbier" included? Seems like there are certain styles that masquerade as ales (perhaps for maketing purposes?)

```{r message=FALSE, warning=FALSE}
ales %>%
  filter(Style == "Witbier")
```

Let's see which beers disguise themselves as ales most often?

```{r message=FALSE, warning=FALSE}
ales %>%
  filter(!str_detect(Style, "Ale") & !str_detect(Style, "IPA")) %>%
  group_by(Style) %>%
  summarise(count=n()) %>%
  ungroup() %>%
  ggplot(aes(reorder(Style,count), count)) +
    theme(axis.text.x = element_text(angle = 90)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    labs(x="Beer Style",
         title = "Styles of Beers With 'Ale' In Their Name")
```

Ok, so after some googling, I found that any one of these beers can be considered an ale. The ale vs. lager distinction is determined by the kind of yeast that is used to make the beer. Cool. We'll use REGEX on the beer name rather than the style to get what we need. Good to know.

Now let's make an indicator that distinguishes IPAs from regular ales and other beer styles.

```{r message=FALSE, warning=FALSE}
dat$beer_type <- if_else(dat$is_IPA == TRUE & dat$is_ale == TRUE, "IPA", 
                         if_else(dat$is_IPA == FALSE & dat$is_ale == TRUE, "Ale",
                                 if_else(dat$is_IPA == TRUE & dat$is_ale == FALSE, "IPA", "Other")))
```


```{r message=FALSE, warning=FALSE}
top_15_styles <- dat %>%
  group_by(Style) %>%
  summarise(count=n()) %>%
  arrange(desc(count)) %>%
  head(15) %>%
  select(Style)
dat %>%
  filter(dat$Style %in% top_15_styles$Style) %>%
  ggplot(aes(Style, fill=beer_type)) +
    geom_bar(stat = "count") +
    coord_flip()
```

Looks like we need to use REGEX on both the beer name and the Style. Clearly something like "American Pale Wheat Ale" is never going to be a lager. We'll do the same thing with IPA's just to be safe.

```{r message=FALSE, warning=FALSE}
dat$is_ale <- str_detect(dat$Beer, "Ale") | str_detect(dat$Style, "Ale")
dat$is_IPA <- str_detect(dat$Beer, "IPA") | str_detect(dat$Style, "IPA") 
dat$beer_type <- if_else(dat$is_IPA == TRUE & dat$is_ale == TRUE, "IPA", 
                         if_else(dat$is_IPA == FALSE & dat$is_ale == TRUE, "Ale",
                                 if_else(dat$is_IPA == TRUE & dat$is_ale == FALSE, "IPA", "Other")))
```

```{r message=FALSE, warning=FALSE}
p <- dat %>%
  filter(dat$Style %in% top_15_styles$Style) %>%
  ggplot(aes(Style, fill=beer_type)) +
    geom_bar(stat = "count") +
    coord_flip()
p
bottom_15_styles <- dat %>%
  group_by(Style) %>%
  summarise(count=n()) %>%
  arrange(desc(count)) %>%
  tail(15) %>%
  select(Style)
p %+% (dat %>% filter(dat$Style %in% bottom_15_styles$Style))
```

Ok, I think our classifications of "ale", "IPA", and "other" are accurate. Let's do some modeling.

```{r message=FALSE, warning=FALSE}
dat %>%
  filter(beer_type != "Other") %>%
  ggplot(aes(x=ABV, y=IBU, color = beer_type)) +
    geom_point()
```

Investigating True Relationship Between ABV and IBU

```{r}
dat %>%
  filter(!beer_type %in% c("Other", "Ale")) %>%
  ggplot(aes(x=ABV, y=IBU)) +
    geom_point() +
    geom_smooth(method = "lm")
```


```{r}

IPA_mod_abv_ibu <- 
  dat %>%
  filter(!beer_type %in% c("Other", "Ale")) %>%
  lm(formula = IBU ~ ABV)

summary(IPA_mod_abv_ibu)

```



```{r}
dat %>%
  filter(!beer_type %in% c("Other", "IPA")) %>%
  ggplot(aes(x=ABV, y=IBU)) +
    geom_point() +
    geom_smooth(method = "lm")
```

```{r}

Ale_mod_abv_ibu <- 
  dat %>%
  filter(!beer_type %in% c("Other", "IPA")) %>%
  lm(formula = IBU ~ ABV)

summary(Ale_mod_abv_ibu)

```



Train/test split data

```{r message=FALSE, warning=FALSE}
dat_mod <- (dat %>% filter(beer_type != "Other"))
train_inds <- sample(nrow(dat_mod), floor(0.7*nrow(dat_mod)))
train <- dat_mod[train_inds,]
test <- dat_mod[-train_inds,]
train <- train[!is.na(train$IBU) & !is.na(train$ABV),]
test <- train[!is.na(test$IBU) & !is.na(test$ABV),]
head(train)
head(test)
```


```{r message=FALSE, warning=FALSE}
preds <- knn(train = train[,3:4], test = test[,3:4], cl = train$beer_type, k = 3)
table(actual=test$beer_type, predicted=preds)
```


Wow, k=3 was a pretty good guess. Our model predicts with 90% accuracy. Let's run a simulation to see which k value is optimal (note that the following code is extremely slow. You will have to give it 5-10 minutes to run)

```{r message=FALSE, warning=FALSE}
sims <- 1000L
iter <- 50L
accs <- vector(mode = "numeric", length = iter)
best_k <- vector(mode = "numeric", length = sims)
for (j in seq_len(sims)) {
  
  train_inds_sim <- sample(nrow(dat_mod), floor(0.7*nrow(dat_mod)))
  train_sim <- dat_mod[train_inds_sim,]
  test_sim <- dat_mod[-train_inds_sim,]
  train_sim <- train_sim[!is.na(train_sim$IBU) & !is.na(train_sim$ABV),]
  test_sim <- test_sim[!is.na(test_sim$IBU) & !is.na(test_sim$ABV),]
  
  
  for (i in seq_len(iter)) {
  
  pred_temp <- knn(train = train_sim[,3:4], test = test_sim[,3:4], cl = train_sim$beer_type, k = i)
  
  accs[[i]] <- sum(if_else(test_sim$beer_type == pred_temp,1,0)) / length(pred_temp)
  }
  
  best_k[[j]] <- which.max(accs)
  
}
best_k <- as.data.frame(best_k)
best_k %>%
  group_by(best_k) %>%
  summarise(count = n()) %>%
    arrange(desc(count))
```


Seems as though more often than not, k = 5 is optimal. Interestingly, k = 1 is the fifth-most optimal choice. Funny enough, using the same data as in the k = 3 example, we lose accuracy at k = 5 (only slightly, though). 

```{r}
preds <- knn(train = train[,3:4], test = test[,3:4], cl = train$beer_type, k = 5)
table(actual=test$beer_type, predicted=preds)
```

```{r}
dat %>%
  ggplot(aes(ABV)) +
    geom_histogram(binwidth = 0.0025)
```



```{r}


dat %>%
  filter(!beer_type %in% c("Other", "Ale") & !is.na(ABV) ) %>%
  mutate(state2 = fct_lump(State, 15)) %>%
  ggplot(aes(reorder(state2, -ABV, FUN = "median") , ABV)) +
  geom_boxplot()

```

```{r}


dat %>%
  filter(!beer_type %in% c("Other", "Ale") & !is.na(ABV) ) %>%
  mutate(state2 = fct_lump(State, 15)) %>%
  oneway.test(formula = ABV ~ state2 ) #using Welch's ANOVA since the standard dev's are clearly not equal

```



Can we model missing IBU values?

Prepping test and training sets


```{r}

model_data <- 
  dat %>%
  mutate(state2 = fct_lump(State, 15)) %>%
  filter(!is.na(IBU))

brewery_sizes <- 
dat %>%
  group_by(Brewery_id) %>%
  summarise(beers_brewed=n()) %>%
  ungroup() %>%
  mutate(brewery_size = if_else(beers_brewed >= 1 & beers_brewed <= 10, "small", 
                                if_else(beers_brewed >= 11 & beers_brewed <= 19, "medium", "large")))


model_data <- left_join(model_data, brewery_sizes, by="Brewery_id")


inds <- sample(nrow(model_data), floor(0.7*nrow(model_data)))

impute_train <- model_data[inds,]

impute_test <- model_data[-inds,]






```

Is the median IBU value (for records that have non-NULL IBU) a good predictor for missing IBU?

```{r}

data.frame(actual=impute_test$IBU, pred=rep(median(impute_train$IBU), nrow(impute_test))) %>% mutate(abserror=abs(actual-pred)) %>% summarise(totalabserr=sum(abserror), meanabserror = mean(abserror) )

```


Probably not. I think we can do better. Let's try a linear model with ABV

```{r}

impute_model_1 <- impute_train %>% lm(formula = IBU ~ ABV)


impute_test %>% add_predictions(impute_model_1) %>% mutate(abserror=abs(IBU - pred)) %>% summarise(totalabserr=sum(abserror),  meanabserror = mean(abserror) )

```


A little better, but not much. We're going to need something more nuanced. Let's try throwing in the state factor we created earlier.


```{r}

impute_model_2 <- impute_train %>% lm(formula = IBU ~ ABV + state2)

impute_test %>% add_predictions(impute_model_2) %>% mutate(abserror=abs(IBU - pred)) %>% summarise(totalabserr=sum(abserror),  meanabserror = mean(abserror) )

```


Wow, not as large of a gain in accuracy as I would have hoped. We probably need to add the beer type as well.


```{r}

impute_model_3 <- impute_train %>% lm(formula = IBU ~ ABV + state2*beer_type)

impute_test %>% add_predictions(impute_model_3) %>% mutate(abserror=abs(IBU - pred)) %>% summarise(totalabserr=sum(abserror),  meanabserror = mean(abserror) )

results_model_3 <- impute_test %>% add_predictions(impute_model_3) %>% mutate(abserror=abs(IBU - pred))

results_model_3

```


```{r}

impute_model_4 <- impute_train %>% lm(formula = IBU ~ ABV + state2*beer_type + brewery_size)

impute_test %>% add_predictions(impute_model_4) %>% mutate(abserror=abs(IBU - pred)) %>% summarise(totalabserr=sum(abserror),  meanabserror = mean(abserror) )

results_model_4 <- impute_test %>% add_predictions(impute_model_4) %>% mutate(abserror=abs(IBU - pred))

results_model_4

```


```{r}

impute_model_5 <- impute_train %>% lm(formula = IBU ~ ABV + state2 + brewery_size*beer_type)

impute_test %>% add_predictions(impute_model_5) %>% mutate(abserror=abs(IBU - pred)) %>% summarise(totalabserr=sum(abserror),  meanabserror = mean(abserror) )

results_model_5 <- impute_test %>% add_predictions(impute_model_5) %>% mutate(abserror=abs(IBU - pred))

results_model_5

```



Looks like model 3 is the most accurate assessment we're going to get without further investigation into where the model is predicting poorly. Let's do that. 

```{r}

results_model_3 %>%
  group_by(beer_type) %>%
  summarise(num=n(),meanError=mean(abserror), medError=median(abserror))

```

Seems like the model misclassifies Other beers less frequently than Ales and IPA's. I wonder why. 

```{r}


summary(impute_model_3)

results_model_3 %>%
  filter(abserror > 60)

```

Ok, so this isn't helping. Our worst misclassification is actually misclassified in the data itself. After looking around online, "Lights Out Vanilla Cream Extra Stout" is definitely not an IPA. Maybe this is an issue with more beers. Let's check for data quality issues with beers that have an absolute error greater than 20. 

```{r}

results_model_3 %>%
  filter(abserror > 20) %>%
  select(Beer, Style, Brewery,beer_type, IBU, pred, abserror)

```



```{r}

dat %>%
  mutate(state2 = fct_lump(State, 15)) %>%
  add_predictions(impute_model_3) %>%
  mutate(IBU_imputed = if_else(is.na(IBU), as.numeric(round(pred)), as.numeric(IBU)), 
         imputed_ind = factor(if_else(is.na(IBU), "Imputed IBU", "Real IBU")) ) %>%
  filter(IBU_imputed > 0) %>%
  ggplot(aes(ABV, IBU_imputed, color = imputed_ind)) +
    theme(legend.title = element_blank()) +
    geom_point() +
    facet_wrap(~beer_type) +
    labs(x="ABV", 
         y="IBU",
         title="ABV vs. IBU by Beer Type")
   

```


```{r}

dat %>%
  mutate(state2 = fct_lump(State, 15)) %>%
  add_predictions(impute_model_3) %>%
  mutate(IBU_imputed = if_else(is.na(IBU), as.numeric(round(pred)), as.numeric(IBU)), 
         imputed_ind = factor(if_else(is.na(IBU), "Imputed IBU", "Real IBU")) ) %>%
  filter(IBU_imputed > 0) %>%
  group_by(State) %>%
  summarise(med_IBU = median(IBU_imputed, na.rm = TRUE)) %>%
  ggplot(aes(reorder(State, -med_IBU, FUN="median"), med_IBU)) +
    theme(axis.text.x = element_text(angle = 90)) +
    geom_bar(stat = "identity")
   

```
