---
title: "EDA For DDS Project"
author: "Jonathon Roach"
date: "10/14/2019"
output: html_document
---

## Introduction

Write introduction here.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




```{r message=FALSE, warning=FALSE}

library(tidyverse)
library(class)
library(stringr)
library(forcats)
theme_set(theme_bw())

beers <- read.csv("http://raw.githubusercontent.com/BivinSadler/MDS-6306-Doing-Data-Science-Fall-2019/master/Unit%208%20and%209%20Case%20Study%201/Beers.csv")

breweries <- read.csv("https://raw.githubusercontent.com/BivinSadler/MDS-6306-Doing-Data-Science-Fall-2019/master/Unit%208%20and%209%20Case%20Study%201/Breweries.csv")

```


Seems like there are Breweries going by the same name in different cities. We may need to accout for this later. It's going to be important for us to reference beweries by Brew_ID rather than name. 

```{r message=FALSE, warning=FALSE}

duplicates <- breweries %>% 
  group_by(Name) %>%
  summarise(count=n()) %>%
  arrange(desc(count)) %>%
  filter(count == 2) %>%
  select(Name)



breweries %>% 
  filter(Name %in% duplicates$Name) %>%
  arrange(Name)


```


Which style of beer is most commonly brewed?


```{r message=FALSE, warning=FALSE}

head(
beers %>%
  group_by(Style) %>%
  summarise(count = n()) %>%
  arrange(desc(count))
)
```


Joining data. Answer to question #2. 

```{r message=FALSE, warning=FALSE}

dat <- left_join(beers, breweries, by=c("Brewery_id" = "Brew_ID")) %>%
       rename(Beer = Name.x, Brewery = Name.y)

head(dat)

```


Which state has the most breweries? Answer to question #1. 

```{r message=FALSE, warning=FALSE}

head(
breweries %>%
  group_by(State) %>%
  summarize(count=n()) %>%
  arrange(desc(count))
)
```

Which brewery produces the most individual beer types?

```{r message=FALSE, warning=FALSE}
head(
dat %>%
  group_by(Brewery) %>%
  summarise(count = n()) %>%
  arrange(desc(count))
)
```


```{r message=FALSE, warning=FALSE}

dat %>%
  ggplot(aes(x=ABV, y=IBU)) +
    geom_point()

```


Let's identify the IPA's

```{r message=FALSE, warning=FALSE}

dat$is_IPA <- str_detect(dat$Style, "IPA")

head(dat %>% filter(is_IPA == TRUE) %>% select(Beer, is_IPA, Style))

```


We can see below that our REGEX isn't picking up anything that it shouldn't. 

```{r message=FALSE, warning=FALSE}

unique(dat[str_detect(dat$Style, "IPA"),]$Style)

```


Now let's identify the ales (including IPA's). We need to be careful. Just looking for the string, "ale" is not a precise solution. For example, "Yard S[ale] Winter Lager" is not an ale, and we don't want it to get picked up in our results.

```{r message=FALSE, warning=FALSE}

dat$is_ale <- str_detect(dat$Beer, "ale")


head(dat %>% filter(is_ale == TRUE) %>% select(Beer, is_ale, Style) )
```

We will also need to be careful using REGEX on the Style column, as simply searching for the "ale" string doesn't guarantee that we're selecting ales either (see for example: "Euro P[ale] Lager")

```{r message=FALSE, warning=FALSE}

unique(dat[str_detect(dat$Style, "ale"),]$Style)

```


Looks like searching for "Ale" is the more sensible decision. 

```{r message=FALSE, warning=FALSE}

unique(dat[str_detect(dat$Style, "Ale"),]$Style)

```


```{r message=FALSE, warning=FALSE}

dat$is_ale <- str_detect(dat$Beer, "Ale")


head(dat %>% filter(is_ale == TRUE) %>% select(Beer, is_ale, Style) )

```

```{r message=FALSE, warning=FALSE}

ales <- dat %>% filter(is_ale == TRUE) %>% select(Beer, is_ale, Style) 

head(
ales %>%
  group_by(Style) %>%
  summarise(count = n()) %>%
  arrange(desc(count))  
)
```

Hmm...Why are there beers like "Witbier" included? Seems like there are certain styles that masquerade as ales (perhaps for maketing purposes?)

```{r message=FALSE, warning=FALSE}


ales %>%
  filter(Style == "Witbier")

```

Let's see which beers disguise themselves as ales most often?

```{r message=FALSE, warning=FALSE}

ales %>%
  filter(!str_detect(Style, "Ale") & !str_detect(Style, "IPA")) %>%
  group_by(Style) %>%
  summarise(count=n()) %>%
  ungroup() %>%
  ggplot(aes(reorder(Style,count), count)) +
    theme(axis.text.x = element_text(angle = 90)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    labs(x="Beer Style",
         title = "Styles of Beers With 'Ale' In Their Name")

```

Ok, so after some googling, I found that any one of these beers can be considered an ale. The ale vs. lager distinction is determined by the kind of yeast that is used to make the beer. Cool. We'll use REGEX on the beer name rather than the style to get what we need. Good to know.

Now let's make an indicator that distinguishes IPAs from regular ales and other beer styles.

```{r message=FALSE, warning=FALSE}

dat$beer_type <- if_else(dat$is_IPA == TRUE & dat$is_ale == TRUE, "IPA", 
                         if_else(dat$is_IPA == FALSE & dat$is_ale == TRUE, "Ale",
                                 if_else(dat$is_IPA == TRUE & dat$is_ale == FALSE, "IPA", "Other")))

```


```{r message=FALSE, warning=FALSE}

top_15_styles <- dat %>%
  group_by(Style) %>%
  summarise(count=n()) %>%
  arrange(desc(count)) %>%
  head(15) %>%
  select(Style)

dat %>%
  filter(dat$Style %in% top_15_styles$Style) %>%
  ggplot(aes(Style, fill=beer_type)) +
    geom_bar(stat = "count") +
    coord_flip()

```

Looks like we need to use REGEX on both the beer name and the Style. Clearly something like "American Pale Wheat Ale" is never going to be a lager. We'll do the same thing with IPA's just to be safe.

```{r message=FALSE, warning=FALSE}

dat$is_ale <- str_detect(dat$Beer, "Ale") | str_detect(dat$Style, "Ale")

dat$is_IPA <- str_detect(dat$Beer, "IPA") | str_detect(dat$Style, "IPA") 

dat$beer_type <- if_else(dat$is_IPA == TRUE & dat$is_ale == TRUE, "IPA", 
                         if_else(dat$is_IPA == FALSE & dat$is_ale == TRUE, "Ale",
                                 if_else(dat$is_IPA == TRUE & dat$is_ale == FALSE, "IPA", "Other")))

```

```{r message=FALSE, warning=FALSE}

p <- dat %>%
  filter(dat$Style %in% top_15_styles$Style) %>%
  ggplot(aes(Style, fill=beer_type)) +
    geom_bar(stat = "count") +
    coord_flip()

p

bottom_15_styles <- dat %>%
  group_by(Style) %>%
  summarise(count=n()) %>%
  arrange(desc(count)) %>%
  tail(15) %>%
  select(Style)

p %+% (dat %>% filter(dat$Style %in% bottom_15_styles$Style))

```

Ok, I think our classifications of "ale", "IPA", and "other" are accurate. Let's do some modeling.

```{r message=FALSE, warning=FALSE}

dat %>%
  filter(beer_type != "Other") %>%
  ggplot(aes(x=ABV, y=IBU, color = beer_type)) +
    geom_point()

```

Investigating True Relationship Between ABV and IBU

```{r}

dat %>%
  filter(!beer_type %in% c("Other", "Ale")) %>%
  ggplot(aes(x=ABV, y=IBU)) +
    geom_point() +
    geom_smooth(method = "lm")

```


```{r}

dat %>%
  filter(!beer_type %in% c("Other", "IPA")) %>%
  ggplot(aes(x=ABV, y=IBU)) +
    geom_point() +
    geom_smooth(method = "lm")

```


Train/test split data

```{r message=FALSE, warning=FALSE}

dat_mod <- (dat %>% filter(beer_type != "Other"))

train_inds <- sample(nrow(dat_mod), floor(0.7*nrow(dat_mod)))

train <- dat_mod[train_inds,]

test <- dat_mod[-train_inds,]

train <- train[!is.na(train$IBU) & !is.na(train$ABV),]

test <- train[!is.na(test$IBU) & !is.na(test$ABV),]

head(train)
head(test)
```


```{r message=FALSE, warning=FALSE}

preds <- knn(train = train[,3:4], test = test[,3:4], cl = train$beer_type, k = 3)

table(actual=test$beer_type, predicted=preds)

```


Wow, k=3 was a pretty good guess. Our model predicts with 90% accuracy. Let's run a simulation to see which k value is optimal (note that the following code is extremely slow. You will have to give it 5-10 minutes to run)

```{r message=FALSE, warning=FALSE}

sims <- 1000L

iter <- 50L

accs <- vector(mode = "numeric", length = iter)

best_k <- vector(mode = "numeric", length = sims)


for (j in seq_len(sims)) {
  
  train_inds_sim <- sample(nrow(dat_mod), floor(0.7*nrow(dat_mod)))

  train_sim <- dat_mod[train_inds_sim,]

  test_sim <- dat_mod[-train_inds_sim,]

  train_sim <- train_sim[!is.na(train_sim$IBU) & !is.na(train_sim$ABV),]

  test_sim <- test_sim[!is.na(test_sim$IBU) & !is.na(test_sim$ABV),]
  
  
  for (i in seq_len(iter)) {
  
  pred_temp <- knn(train = train_sim[,3:4], test = test_sim[,3:4], cl = train_sim$beer_type, k = i)
  
  accs[[i]] <- sum(if_else(test_sim$beer_type == pred_temp,1,0)) / length(pred_temp)
  }
  
  best_k[[j]] <- which.max(accs)
  
}

best_k <- as.data.frame(best_k)

best_k %>%
  group_by(best_k) %>%
  summarise(count = n()) %>%
    arrange(desc(count))

```


Seems as though more often than not, k = 5 is optimal. Interestingly, k = 1 is the fifth-most optimal choice. Funny enough, using the same data as in the k = 3 example, we lose accuracy at k = 5 (only slightly, though). 

```{r}

preds <- knn(train = train[,3:4], test = test[,3:4], cl = train$beer_type, k = 5)

table(actual=test$beer_type, predicted=preds)

```

```{r}

dat %>%
  ggplot(aes(ABV)) +
    geom_histogram(binwidth = 0.0025)

```

Addressing missing values in each column. Answer to question #3. 


```{r}

lapply(dat, function(x)mean(is.na(x)))

```


Question 4: Compute median ABV and IBU for each state and plot.

```{r}

dat %>%
  mutate(State = fct_reorder(State, ABV, .fun = median, na.rm = TRUE, .desc = TRUE)) %>%
  group_by(State) %>%
  summarise(medABV = median(ABV, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(aes(State, medABV)) +
  theme(axis.text.x = element_text(angle = 90)) +
  geom_bar(stat = "identity")


```

```{r}

dat %>%
  mutate(State = fct_reorder(State, IBU, .fun = median, na.rm = TRUE, .desc = TRUE)) %>%
  group_by(State) %>%
  summarise(medIBU = median(IBU, na.rm = TRUE)) %>%
  ungroup() %>%
  ggplot(aes(State, medIBU)) +
  theme(axis.text.x = element_text(angle = 90)) +
  geom_bar(stat = "identity")


```

Which state has the maximum ABV beer? Answer to question #5. 

```{r}

dat %>%
  arrange(desc(ABV)) %>%
  select(State, ABV, Beer)

```

Which state has the most bitter beer? Answer to question #5. 

```{r}

dat %>%
  arrange(desc(IBU)) %>%
  select(State, IBU, Beer)


```


